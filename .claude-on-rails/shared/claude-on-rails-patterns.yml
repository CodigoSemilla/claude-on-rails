# ClaudeOnRails Patterns Configuration

Rails_Patterns:
  Service_Objects:
    purpose: "Encapsulate complex business logic"
    when_to_use:
      - Multiple models involved
      - External API calls
      - Complex validations
      - Business rules
    
    structure:
      - Single public method (call/perform)
      - Clear inputs and outputs
      - Testable in isolation
      - Explicit dependencies
    
    example_structure: |
      class CreateOrder
        def initialize(user, items, payment_method)
          @user = user
          @items = items
          @payment_method = payment_method
        end
        
        def call
          # Business logic here
        end
      end

  Form_Objects:
    purpose: "Handle complex forms spanning multiple models"
    when_to_use:
      - Multi-model forms
      - Virtual attributes
      - Complex validations
      - Conditional logic
    
    structure:
      - Include ActiveModel modules
      - Define attributes
      - Custom validations
      - Save method
    
    example_structure: |
      class RegistrationForm
        include ActiveModel::Model
        
        attr_accessor :email, :password, :company_name
        
        validates :email, presence: true
        
        def save
          return false unless valid?
          # Create user and company
        end
      end

  Query_Objects:
    purpose: "Encapsulate complex database queries"
    when_to_use:
      - Complex ActiveRecord queries
      - Reusable query logic
      - Performance optimization
      - Query composition
    
    structure:
      - Class methods for queries
      - Chainable scopes
      - Clear naming
      - SQL optimization
    
    example_structure: |
      class OrderQuery
        def self.recent(days = 30)
          Order.where('created_at > ?', days.days.ago)
        end
        
        def self.by_status(status)
          Order.where(status: status)
        end
      end

  Presenter_Objects:
    purpose: "Prepare data for views"
    when_to_use:
      - Complex view logic
      - Formatting concerns
      - Multiple models in view
      - Decoration patterns
    
    structure:
      - Wrap model(s)
      - Presentation methods
      - View helpers
      - No business logic
    
    example_structure: |
      class OrderPresenter
        def initialize(order)
          @order = order
        end
        
        def formatted_total
          "$#{@order.total}"
        end
      end

  Policy_Objects:
    purpose: "Encapsulate authorization logic"
    when_to_use:
      - Complex permissions
      - Role-based access
      - Resource authorization
      - API authorization
    
    structure:
      - User and resource
      - Permission methods
      - Scope support
      - Clear naming
    
    example_structure: |
      class PostPolicy
        def initialize(user, post)
          @user = user
          @post = post
        end
        
        def update?
          @user.admin? || @post.author == @user
        end
      end

Background_Jobs:
  Patterns:
    Idempotent_Jobs:
      - Make jobs re-runnable
      - Use unique job IDs
      - Check for completion
      - Handle duplicates
    
    Error_Handling:
      - Retry strategies
      - Dead letter queues
      - Error notifications
      - Graceful degradation
    
    Performance:
      - Batch processing
      - Priority queues
      - Job scheduling
      - Resource limits

Testing_Patterns:
  Shared_Examples:
    purpose: "DRY up common test scenarios"
    usage:
      - Common behaviors
      - Interface testing
      - Authorization specs
      - API responses
    
    structure: |
      RSpec.shared_examples "authenticated endpoint" do
        context "without authentication" do
          it "returns 401" do
            # Test logic
          end
        end
      end

  Factory_Patterns:
    Traits:
      - Reusable states
      - Composition over inheritance
      - Clear naming
      - Minimal data
    
    Associations:
      - Explicit relationships
      - Avoid cascades
      - Use build strategies
      - Performance consideration

  Test_Doubles:
    When_To_Mock:
      - External services
      - Slow operations
      - Time-dependent code
      - Random values
    
    Best_Practices:
      - Verify interactions
      - Use real objects when possible
      - Mock at boundaries
      - Avoid over-mocking

API_Patterns:
  Versioning:
    Strategies:
      - URL versioning (/api/v1)
      - Header versioning
      - Accept header
      - Query parameter
    
    Best_Practices:
      - Version from start
      - Deprecation policy
      - Documentation
      - Backward compatibility

  Error_Handling:
    Standard_Responses:
      - Consistent format
      - Error codes
      - Human messages
      - Debug information
    
    Status_Codes:
      - Use appropriate codes
      - 422 for validation
      - 401 vs 403
      - 5xx for server errors

  Serialization:
    Patterns:
      - Use serializers
      - Version serializers
      - Partial responses
      - Nested resources
    
    Performance:
      - Avoid N+1
      - Pagination
      - Field filtering
      - Caching headers